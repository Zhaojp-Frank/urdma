This repository contains the DPDK verbs source along with some demo
applications.

Requirements
------------

 - Linux kernel >= 3.17.8
 - libibverbs >= 1.2.0 (versions less than 1.1.8 do not support verbs extensions
   and version 1.1.8 has a broken extensions ABI)
 - librdmacm >= 1.0.21
 - DPDK >= 16.04 built as shared libraries (CONFIG_RTE_BUILD_SHARED_LIB=y)
     Note: DPDK 2.2.0 as provided by the CentOS, Fedora, etc.
     repositories will work as long as your distribution package provides a
     linker script called libdpdk.so
 - libnl-3 and libnl-route-3
 - json-c
 - uthash (included in Fedora, Ubuntu, openSUSE, and EPEL for RHEL
   repositories)

Setup instructions
------------------

I am assuming a default installation of CentOS 7.

To build this package, RTE_SDK and RTE_TARGET need to be exported into the environment:

$ export RTE_SDK=${prefix}/share/dpdk
$ export RTE_TARGET=x86_64-native-linuxapp-gcc

If you are pulling this from a fresh git clone, first run:

$ autoreconf -i

Then this follows the normal autotools-style build:

$ ./configure --sysconfdir /etc
$ make
$ sudo make install

Note that sysconfdir must match that of your libibverbs installation, in
order for the verbs library to find the urdma driver.

The configure script will look for your kernel source directory in the
typical location by default (/lib/modules/`uname -r`/source).  You can
set the KERNELDIR environment variable to specify a different location;
for example, if you are building against a different kernel version than
what it installed locally.

By default, this package is compiled with -march=native as this enables
machine instructions that are required by DPDK.  You can adjust this by
setting the MACHINE_CFLAGS environment variable.

To run an application with this driver, the KNI and urdma modules must be loaded:

$ sudo modprobe rte_kni
$ sudo modprobe urdma device_count=2

The device count is the number of devices that should be accessible via DPDK.
These verbs devices are pre-created so libibverbs will call our userspace
driver to initialize them.

Known Issues
------------

 - There is a potential race condition with completion channels, where a
   completion event can get lost, and thus a thread waiting on
   ibv_get_cq_event() will never wake up, leading to a deadlock.  A cause has
   not been identified, but the issue has not been reproduced with the "extra"
   lock added around the rte_ring operations in do_poll_cq() and
   finish_post_cqe().

 - There is the possibility of a hang in the kernel module if the user process
   is killed while between the read() and write() calls on event_fd in
   poll_conn_state().  This is because rdma_destroy_id() in the kernel will
   block until the connection attempt completes, but itself prevents our
   event_fd from being closed which would unblock it.

 - The progress thread will use 100% CPU since it must busy-poll on the KNI
   interfaces (there is no way to sleep until the process gets an event).
